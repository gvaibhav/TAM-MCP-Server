#!/usr/bin/env node

/**
 * Unit tests for TAM MCP Server tools
 * Tests the market analysis tools directly without server transport
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
// Corrected import path for MarketAnalysisTools
import { MarketAnalysisTools } from '../../dist/tools/market-tools.js'; 
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
// Corrected import path for NotificationService
import { NotificationService } from '../../dist/notifications/notification-service.js'; 
// Import the logger mock
import { logger } from '../setup.js';

// Mock the DataService - we'll spy on the static instance later
// Corrected import path for DataService mock
vi.mock('../../dist/services/dataService.js', () => {
  return {
    DataService: vi.fn().mockImplementation(() => ({
      searchIndustries: vi.fn(),
      getIndustryById: vi.fn(),
      getMarketSize: vi.fn(),
      generateMarketForecast: vi.fn(),
      getSupportedCurrencies: vi.fn(),
      getMarketOpportunities: vi.fn(),
      calculateTam: vi.fn(),
      calculateSam: vi.fn(),
      compareMarkets: vi.fn(),
      validateMarketData: vi.fn(),
      forecastMarket: vi.fn(),
      getMarketSegments: vi.fn(),
      // Added getSpecificDataSourceData to the mock
      getSpecificDataSourceData: vi.fn() 
    }))
  };
});

// Mock utils functions
// Corrected import path for utils mock
vi.mock('../../dist/utils/index.js', () => {
  return {
    logger: {
      info: vi.fn(),
      warn: vi.fn(),
      error: vi.fn(),
      debug: vi.fn()
    },
    createAPIResponse: vi.fn((data, source) => ({
      success: true, // Assuming createAPIResponse implies success
      content: data, // Changed 'data' to 'content' to match tool output
      metadata: {
        source,
        timestamp: '2025-06-06T12:00:00Z'
      }
    })),
    createErrorResponse: vi.fn((message, code) => { // Added code parameter
      return {
        success: false, // Assuming createErrorResponse implies failure
        error: { message, code }, // Added code to error object
        metadata: {
          timestamp: '2025-06-06T12:00:00Z'
        }
      }
    }),
    handleToolError: vi.fn((error, toolName) => {
      return {
        success: false, // Assuming handleToolError implies failure
        error: {
          message: error instanceof Error ? error.message : String(error),
          toolName,
          // Propagate Zod validation error details if present
          details: error.issues ? error.issues.map(issue => ({ path: issue.path, message: issue.message })) : undefined,
          code: error.issues ? 'VALIDATION_ERROR' : 'TOOL_ERROR' // Add a code for validation errors
        },
        metadata: {
          timestamp: '2025-06-06T12:00:00Z'
        }
      }
    }),
    validatePositiveNumber: vi.fn(),
    validatePercentage: vi.fn(),
    validateYear: vi.fn(),
    validateCurrency: vi.fn(),
    validateRegion: vi.fn(),
    formatCurrency: vi.fn((value) => `$${value.toLocaleString()}`),
    formatPercentage: vi.fn((value) => `${(value * 100).toFixed(1)}%`),
    calculateCAGR: vi.fn(),
    calculateConfidenceScore: vi.fn((params) => 0.85)
  };
});

async function testToolDefinitions() {
  console.log('🧪 Testing tool definitions...');
  
  const tools = MarketAnalysisTools.getToolDefinitions();
  console.log(`✅ Found ${tools.length} tools:`);
  
  // Validate each tool has required properties
  const requiredProperties = ['name', 'description', 'inputSchema'];
  let allValid = true;
  
  tools.forEach(tool => {
    console.log(`   - ${tool.name}: ${tool.description}`);
    
    // Check required properties
    for (const prop of requiredProperties) {
      if (!tool[prop]) {
        console.error(`   ❌ Missing ${prop} in tool ${tool.name}`);
        allValid = false;
      }
    }
  });
  
  if (allValid) {
    console.log('✅ All tools have valid definitions\n');
  } else {
    throw new Error('Some tools have invalid definitions');
  }
  
  return tools;
}

async function testIndustrySearch() {
  console.log('🧪 Testing industry search tool...');
  
  const searchResult = await MarketAnalysisTools.industrySearch({
    query: 'cloud computing',
    filters: {}
  });
  
  console.log('✅ Industry search results:');
  console.log(JSON.stringify(searchResult, null, 2));
  console.log();
  
  // Validate response structure
  if (!searchResult.success !== undefined) {
    throw new Error('Industry search result missing success field');
  }
  
  if (!searchResult.metadata) {
    throw new Error('Industry search result missing metadata');
  }
  
  return searchResult;
}

async function testMarketSize() {
  console.log('🧪 Testing market size tool...');
  
  const marketResult = await MarketAnalysisTools.marketSize({
    industry: 'saas-software',
    region: 'North America',
    year: '2024'
  });
  
  console.log('✅ Market size results:');
  console.log(JSON.stringify(marketResult, null, 2));
  console.log();
  
  // Validate response structure
  if (marketResult.success === undefined) {
    throw new Error('Market size result missing success field');
  }
  
  if (!marketResult.metadata) {
    throw new Error('Market size result missing metadata');
  }
  
  return marketResult;
}

async function testTAMCalculator() {
  console.log('🧪 Testing TAM calculator tool...');
  
  const tamResult = await MarketAnalysisTools.tamCalculator({
    industry: 'Software as a Service (SaaS)',
    region: 'Global',
    methodology: 'top-down',
    dataPoints: {
      totalMarketValue: 150000000000,
      targetSegmentPercentage: 15,
      geographicPenetration: 85
    }
  });
  
  console.log('✅ TAM calculation results:');
  console.log(JSON.stringify(tamResult, null, 2));
  console.log();
  
  // Validate response structure
  if (tamResult.success === undefined) {
    throw new Error('TAM calculation result missing success field');
  }
  
  return tamResult;
}

async function runAllToolTests() {
  console.log('🚀 Starting TAM MCP Server Unit Tests...\n');
  
  try {
    await testToolDefinitions();
    await testIndustrySearch();
    await testMarketSize();
    await testTAMCalculator();
    
    console.log('🎉 All unit tests passed! TAM MCP Server tools are working correctly.');
    return true;
  } catch (error) {
    console.error('❌ Unit tests failed:', error.message);
    return false;
  }
}

describe('Market Analysis Tools Tests', () => {
  describe('Tool Definitions', () => {
    it('should return a list of tool definitions', () => {
      const tools = MarketAnalysisTools.getToolDefinitions();
      expect(tools).toBeInstanceOf(Array);
      expect(tools.length).toBeGreaterThan(0);
      
      // Verify each tool has the required properties
      tools.forEach((tool) => {
        expect(tool).toHaveProperty('name');
        expect(tool).toHaveProperty('description');
        expect(tool).toHaveProperty('inputSchema');
      });
      
      // Verify specific tools exist
      const toolNames = tools.map((tool) => tool.name);
      expect(toolNames).toContain('industry_search');
      expect(toolNames).toContain('market_size');
      expect(toolNames).toContain('tam_calculator');
    });
  });

  describe('Industry Search', () => {
    const mockIndustries = [
      {
        id: 'tech-software',
        name: 'Software & Technology',
        description: 'Software development and tech platforms',
        naicsCode: '541511',
        sicCode: '7372',
        keyMetrics: {
          marketSize: 659000000000,
          growthRate: 0.11
        },
        subIndustries: ['saas', 'enterprise-software'],
        lastUpdated: '2025-06-01'
      }
    ];

    beforeEach(() => {
      vi.clearAllMocks();
    });

    it('should return search results successfully', async () => {
      // Setup mock
      const mockSearchIndustries = vi.spyOn(MarketAnalysisTools.dataService, 'searchIndustries')
        .mockResolvedValue(mockIndustries);
      
      const result = await MarketAnalysisTools.industrySearch({
        query: 'software',
        limit: 10,
        includeSubIndustries: true
      });
      
      expect(mockSearchIndustries).toHaveBeenCalledWith('software', 10);
      // Adjusted expectations to match the new createAPIResponse structure
      expect(result?.success).toBe(true);
      expect(result?.content?.industries).toBeDefined();
      expect(result?.content?.industries.length).toBe(1);
      expect(result?.content?.industries[0].id).toBe('tech-software');
      expect(result?.content?.industries[0].subIndustries).toBeDefined();
    });
    
    it('should exclude subIndustries when not requested', async () => {
      // Setup mock
      vi.spyOn(MarketAnalysisTools.dataService, 'searchIndustries')
        .mockResolvedValue(mockIndustries);
      
      const result = await MarketAnalysisTools.industrySearch({
        query: 'software',
        limit: 10,
        includeSubIndustries: false
      });
      
      expect(result?.data?.industries[0].subIndustries).toBeUndefined();
    });
    
    it('should provide search tips when no results found', async () => {
      // Setup mock to return empty array
      vi.spyOn(MarketAnalysisTools.dataService, 'searchIndustries')
        .mockResolvedValue([]);
      
      const result = await MarketAnalysisTools.industrySearch({
        query: 'nonexistent industry',
        limit: 10
      });
      
      expect(result?.data?.industries).toHaveLength(0);
      expect(result?.data?.searchTips).toBeDefined();
      expect(result?.data?.searchTips?.length).toBeGreaterThan(0);
    });
    
    it('should handle errors correctly', async () => {
      // Setup mock to throw an error
      vi.spyOn(MarketAnalysisTools.dataService, 'searchIndustries')
        .mockRejectedValue(new Error('Database connection failed'));
      
      const result = await MarketAnalysisTools.industrySearch({
        query: 'software',
        limit: 10
      });
      
      expect(result?.error).toBeDefined();
      expect(result?.error?.message).toBe('Database connection failed');
      expect(result?.error?.toolName).toBe('industry_search');
    });
  });

  describe('Industry Data', () => {
    const mockIndustry = {
      id: 'tech-software',
      name: 'Software & Technology',
      description: 'Software development and tech platforms',
      naicsCode: '541511',
      sicCode: '7372',
      parentIndustry: 'technology',
      subIndustries: ['saas', 'enterprise-software'],
      keyMetrics: {
        marketSize: 659000000000,
        growthRate: 0.11,
        cagr: 0.085,
        volatility: 0.25
      },
      geography: ['global'],
      lastUpdated: '2025-06-01'
    };
    
    const mockMarketSize = {
      value: 659000000000,
      year: 2025,
      region: 'global',
      confidenceScore: 0.9,
      methodology: 'bottom-up',
      sources: ['industry-report-1', 'industry-report-2']
    };

    beforeEach(() => {
      vi.clearAllMocks();
    });

    it('should return industry data successfully', async () => {
      vi.spyOn(MarketAnalysisTools.dataService, 'getIndustryById')
        .mockResolvedValue(mockIndustry);
      vi.spyOn(MarketAnalysisTools.dataService, 'getMarketSize')
        .mockResolvedValue(mockMarketSize);
      
      const result = await MarketAnalysisTools.industryData({
        industryId: 'tech-software',
        includeMetrics: true
      });
      
      expect(MarketAnalysisTools.dataService.getIndustryById).toHaveBeenCalledWith('tech-software');
      expect(result?.data?.id).toBe('tech-software');
      expect(result?.data?.metrics).toBeDefined();
    });
    
    it('should not include metrics when not requested', async () => {
      vi.spyOn(MarketAnalysisTools.dataService, 'getIndustryById')
        .mockResolvedValue(mockIndustry);
      
      const result = await MarketAnalysisTools.industryData({
        industryId: 'tech-software',
        includeMetrics: false
      });
      
      expect(result?.data?.metrics).toBeUndefined();
    });
    
    it('should handle region parameter correctly', async () => {
      vi.spyOn(MarketAnalysisTools.dataService, 'getIndustryById')
        .mockResolvedValue(mockIndustry);
      const mockGetMarketSize = vi.spyOn(MarketAnalysisTools.dataService, 'getMarketSize')
        .mockResolvedValue(mockMarketSize);
      
      const result = await MarketAnalysisTools.industryData({
        industryId: 'tech-software',
        includeMetrics: true,
        region: 'north-america'
      });
      
      expect(mockGetMarketSize).toHaveBeenCalledWith('tech-software', 'north-america');
    });
    
    it('should handle industry not found', async () => {
      vi.spyOn(MarketAnalysisTools.dataService, 'getIndustryById')
        .mockResolvedValue(null);
      
      const result = await MarketAnalysisTools.industryData({
        industryId: 'nonexistent',
        includeMetrics: true
      });
      
      expect(result?.error).toBeDefined();
      expect(result?.error?.message).toContain('Industry not found');
    });
  });

  describe('Market Size', () => {
    const mockMarketSize = {
      value: 659000000000,
      year: 2025,
      region: 'global',
      confidenceScore: 0.9,
      methodology: 'bottom-up',
      sources: ['industry-report-1', 'industry-report-2'],
      segments: [
        { name: 'Enterprise', value: 350000000000, percentage: 0.53, growthRate: 0.09, description: 'Enterprise software' },
        { name: 'Consumer', value: 309000000000, percentage: 0.47, growthRate: 0.13, description: 'Consumer software' }
      ]
    };

    beforeEach(() => {
      vi.clearAllMocks();
    });

    it('should return market size data successfully', async () => {
      vi.spyOn(MarketAnalysisTools.dataService, 'getMarketSize')
        .mockResolvedValue(mockMarketSize);
      
      const result = await MarketAnalysisTools.marketSize({
        industryId: 'tech-software',
        region: 'global',
        currency: 'USD'
      });
      
      expect(MarketAnalysisTools.dataService.getMarketSize).toHaveBeenCalledWith('tech-software', 'global', undefined);
      expect(result?.data?.marketSize?.value).toBe(659000000000);
      expect(result?.data?.segments?.length).toBe(2);
    });
    
    it('should handle year parameter correctly', async () => {
      vi.spyOn(MarketAnalysisTools.dataService, 'getMarketSize')
        .mockResolvedValue(mockMarketSize);
      
      const result = await MarketAnalysisTools.marketSize({
        industryId: 'tech-software',
        region: 'global',
        year: 2024,
        currency: 'USD'
      });
      
      expect(MarketAnalysisTools.dataService.getMarketSize).toHaveBeenCalledWith('tech-software', 'global', 2024);
    });
    
    it('should handle market data not available', async () => {
      vi.spyOn(MarketAnalysisTools.dataService, 'getMarketSize')
        .mockResolvedValue(null);
      
      const result = await MarketAnalysisTools.marketSize({
        industryId: 'tech-software',
        region: 'global',
        currency: 'USD'
      });
      
      expect(result?.error).toBeDefined();
      expect(result?.error?.message).toContain('Market size data not available');
    });
  });

  describe('TAM Calculator', () => {
    const mockIndustry = {
      id: 'tech-software',
      name: 'Software & Technology',
      keyMetrics: {
        marketSize: 659000000000,
        growthRate: 0.11
      }
    };
    
    const mockMarketSize = {
      value: 659000000000,
      year: 2025,
      region: 'global',
      confidenceScore: 0.9,
      methodology: 'bottom-up',
      sources: ['industry-report-1', 'industry-report-2']
    };

    beforeEach(() => {
      vi.clearAllMocks();
    });

    it('should calculate TAM using bottom-up approach', async () => {
      vi.spyOn(MarketAnalysisTools.dataService, 'getIndustryById')
        .mockResolvedValue(mockIndustry);
      vi.spyOn(MarketAnalysisTools.dataService, 'getMarketSize')
        .mockResolvedValue(mockMarketSize);
      
      const result = await MarketAnalysisTools.tamCalculator({
        industryId: 'tech-software',
        region: 'global',
        population: 1000000,
        penetrationRate: 0.2,
        averageSpending: 1500,
        includeScenarios: true
      });
      
      expect(result?.data?.totalAddressableMarket).toBe(300000000); // 1M * 0.2 * 1500
      expect(result?.data?.methodology).toContain('Bottom-up');
      expect(result?.data?.scenarios).toBeDefined();
      expect(result?.data?.scenarios?.optimistic).toBe(450000000); // 300M * 1.5
    });
    
    it('should calculate TAM using top-down approach when bottom-up params missing', async () => {
      vi.spyOn(MarketAnalysisTools.dataService, 'getIndustryById')
        .mockResolvedValue(mockIndustry);
      vi.spyOn(MarketAnalysisTools.dataService, 'getMarketSize')
        .mockResolvedValue(mockMarketSize);
      
      const result = await MarketAnalysisTools.tamCalculator({
        industryId: 'tech-software',
        region: 'global',
        includeScenarios: false
      });
      
      expect(result?.data?.totalAddressableMarket).toBe(659000000000);
      expect(result?.data?.methodology).toContain('Top-down');
      expect(result?.data?.scenarios?.optimistic).toBe(659000000000); // Same as realistic when not including scenarios
    });
    
    it('should handle missing industry or market data', async () => {
      vi.spyOn(MarketAnalysisTools.dataService, 'getIndustryById')
        .mockResolvedValue(null);
      
      const result = await MarketAnalysisTools.tamCalculator({
        industryId: 'nonexistent',
        region: 'global'
      });
      
      expect(result?.error).toBeDefined();
      expect(result?.error?.message).toContain('Unable to calculate TAM');
    });
  });
});

// NotificationService tests
describe.skip('NotificationService Tests', () => {
  let notificationService;
  let mockServer;

  beforeEach(() => {
    vi.clearAllMocks();
    // Create a mock server
    mockServer = {
      notification: vi.fn().mockResolvedValue(undefined)
    };
    notificationService = new NotificationService(mockServer);
  });

  describe('Basic Functionality', () => {
    it('should enable notifications', () => {
      notificationService.setEnabled(true);
      // Use the logger from the imported mock
      expect(logger.info).toHaveBeenCalled();
    });

    it('should disable notifications', () => {
      notificationService.setEnabled(false);
      // Use the logger from the imported mock
      expect(logger.info).toHaveBeenCalled();
    });
  });

  describe('Notification Methods', () => {
    it('should send progress notification when enabled', async () => {
      notificationService.setEnabled(true);
      
      await notificationService.sendProgress({
        progressToken: '123',
        progress: 50,
        total: 100,
        message: 'Processing data'
      });
      
      expect(mockServer.notification).toHaveBeenCalledWith({
        method: 'notifications/progress',
        params: {
          progressToken: '123',
          progress: 50,
          total: 100,
          message: 'Processing data'
        }
      });
    });
    
    it('should not send progress notification when disabled', async () => {
      notificationService.setEnabled(false);
      
      await notificationService.sendProgress({
        progress: 50,
        total: 100
      });
      
      expect(mockServer.notification).not.toHaveBeenCalled();
    });

    it('should send market analysis update', async () => {
      notificationService.setEnabled(true);
      
      const notification = {
        type: 'market_analysis',
        message: 'New market analysis available',
        data: { marketSize: 500000000 },
        timestamp: '2025-06-06T12:00:00Z'
      };
      
      await notificationService.sendMarketAnalysisUpdate(notification);
      
      expect(mockServer.notification).toHaveBeenCalledWith({
        method: 'notifications/market_analysis',
        params: notification
      });
    });

    it('should send error notification', async () => {
      notificationService.setEnabled(true);
      
      await notificationService.sendError({
        error: 'Failed to calculate TAM',
        tool: 'tam_calculator',
        timestamp: '2025-06-06T12:00:00Z'
      });
      
      expect(mockServer.notification).toHaveBeenCalledWith({
        method: 'notifications/error',
        params: {
          error: 'Failed to calculate TAM',
          tool: 'tam_calculator',
          timestamp: '2025-06-06T12:00:00Z'
        }
      });
    });

    it('should send message notification', async () => {
      notificationService.setEnabled(true);
      
      await notificationService.sendMessage('info', 'Server started');
      
      expect(mockServer.notification).toHaveBeenCalledWith({
        method: 'notifications/message',
        params: {
          level: 'info',
          logger: 'tam-mcp-server',
          data: 'Server started', 
          timestamp: expect.any(String)
        }
      });
    });
  });

  describe('Higher-Level Methods', () => {
    it('should send calculation status', async () => {
      notificationService.setEnabled(true);
      
      await notificationService.sendCalculationStatus('TAM', 'completed', { result: 500000000 });
      
      expect(mockServer.notification).toHaveBeenCalledWith(expect.objectContaining({
        method: 'notifications/market_analysis',
        params: expect.objectContaining({
          type: 'calculation',
          message: 'TAM calculation completed'
        })
      }));
    });
    
    it('should send data fetch status', async () => {
      notificationService.setEnabled(true);
      
      await notificationService.sendDataFetchStatus('industry database', 'started');
      
      expect(mockServer.notification).toHaveBeenCalledWith(expect.objectContaining({
        method: 'notifications/market_analysis',
        params: expect.objectContaining({
          type: 'data_fetch',
          message: 'Data fetch from industry database started'
        })
      }));
    });
    
    it('should send validation status', async () => {
      notificationService.setEnabled(true);
      
      await notificationService.sendValidationStatus('market data', 'completed', { valid: true });
      
      expect(mockServer.notification).toHaveBeenCalledWith(expect.objectContaining({
        method: 'notifications/market_analysis',
        params: expect.objectContaining({
          type: 'validation',
          message: 'market data validation completed'
        })
      }));
    });
  });
});
